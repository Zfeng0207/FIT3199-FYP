import os
import io
import base64
import ast
from typing import List
import time

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from dotenv import load_dotenv
from pydantic import BaseModel, Field

from langchain.tools import tool

# from stroke_agent.stroke_data.icd_mapping_dict import icd_code_dict
import stroke_agent.agent as agent
from flask import Flask, request, send_file

icd_code_dict = {
    "I481": "Persistent atrial fibrillation",
    "I4891": "Atrial fibrillation, unspecified",
    "I110": "Hypertensive heart disease with heart failure",
    "I120": "Hypertensive chronic kidney disease with stage 5 chronic kidney disease or end stage renal disease",
    "I132": "Hypertensive heart and chronic kidney disease with heart failure and with stage 5 CKD or ESRD",
    "I210": "ST elevation (STEMI) myocardial infarction of anterior wall",
    "I200": "Unstable angina",
    "I255": "Ischemic cardiomyopathy",
    "I7025": "Atherosclerosis of native arteries of other extremities with ulceration",
    "I447": "Left bundle-branch block, unspecified",
    "I451": "Other and unspecified right bundle-branch block",
    "I440": "First degree atrioventricular block",
    "R000": "Tachycardia, unspecified",
    "R001": "Bradycardia, unspecified",
    "I5043": "Acute on chronic combined systolic and diastolic heart failure",
    "I081": "Rheumatic disorders of both mitral and tricuspid valves",
    "I340": "Nonrheumatic mitral (valve) insufficiency",
    "I359": "Nonrheumatic aortic valve disorder, unspecified",
    "I078": "Other rheumatic tricuspid valve diseases",
    "I428": "Other cardiomyopathies",
    "E1129": "Type 2 diabetes mellitus with other diabetic kidney complication",
    "E103": "Type 1 diabetes mellitus with ophthalmic complications",
    "E660": "Obesity due to excess calories",
    "N186": "End stage renal disease",
    "D631": "Anemia in chronic kidney disease",
    "D65": "Disseminated intravascular coagulation [defibrination syndrome]",
    "C925": "Acute myelomonocytic leukemia",
    "A40": "Streptococcal sepsis",
    "A419": "Sepsis, unspecified organism",
    "R570": "Cardiogenic shock"
}

from pydantic import BaseModel
from langchain.tools import tool

# Schema for the input question
class RagToolSchema(BaseModel):
    question: str

# Stroke RAG Tool
@tool(args_schema=RagToolSchema)
def stroke_retriever_tool(question: str) -> str:
    """Retrieve semantically similar documents to answer user questions related to Stroke"""
    print("INSIDE STROKE RETRIEVER NODE")
    response = agent.stroke_rag_chain.invoke({"input": question})
    return response.get("answer")

# Prevention RAG Tool
@tool(args_schema=RagToolSchema)
def prevention_retriever_tool(question: str) -> str:
    """Retrieve semantically similar documents to answer user questions related to Stroke Prevention"""
    print("INSIDE PREVENTION RETRIEVER NODE")
    response = agent.prevention_rag_chain.invoke({"input": question})
    return response.get("answer")

vitals_data = pd.read_csv("stroke_agent/stroke_data/vitals_data.csv")
vitals_data["prediction_score"] = vitals_data["prediction_score"].apply(ast.literal_eval)
vitals_data["res"] = vitals_data["res"].apply(ast.literal_eval)

class AnalyzerToolSchema(BaseModel):
    subject_id: int = Field(..., description="The subject ID from the hospital records")
    admission_id: int = Field(..., description="The admission ID corresponding to the hospital stay")

@tool(args_schema=AnalyzerToolSchema)
def ecg_analyzer(subject_id: int, admission_id: int):
    """Tool to retrieve the top 5 diseases predicted by the ECG data of a patient."""
    print("INSIDE ANALYZER NODE")
    # time.sleep(6)

    row = vitals_data[
        (vitals_data['subject_id'] == subject_id) &
        (vitals_data['admission_id'] == admission_id)
    ]
    
    if row.empty:
        return f"No data found for subject ID {subject_id} and admission ID {admission_id}."

    pred_scores = row.iloc[0]['prediction_score']
    icd_codes = list(icd_code_dict.keys())

    score_pairs = list(zip(icd_codes, pred_scores))
    score_pairs.sort(key=lambda x: x[1], reverse=True)

    top5 = score_pairs[:5]
    top5_formatted = "\n".join([
        f"{i+1}. **{icd_code_dict[code]} ({code})** ‚Äì *Score: {score:.2f}*"
        for i, (code, score) in enumerate(top5)
    ])

    full_ranking = "\n".join([
        f"- {icd_code_dict[code]} ({code}): {score:.2f}" for code, score in score_pairs
    ])

    notes_section = (
        "**üìù Notes:**\n"
        "- These results are generated by a deep learning model trained for multilabel ECG classification.\n"
        "- Additional diagnoses were predicted with lower confidence and are excluded from this summary."
    )

    return (
        f"üìà **ECG Analysis Summary**\n"
        f"**Subject ID:** `{subject_id}`\n"
        f"**Admission ID:** `{admission_id}`\n\n"
        f"üîç **Top 5 Predicted Conditions:**\n{top5_formatted}\n\n"
        f"üìä **Complete Prediction Ranking:**\n{full_ranking}\n\n"
        f"{notes_section}\n\n"
        "Would you like to further understand what the top 5 predicted ICD codes are, and how they relate to stroke? "
    )

import re
import io
import base64
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from flask import Response
from markupsafe import Markup

def generate_patient_ecg_plot_html(msg: str) -> Response:
    # Extract subject_id and admission_id using regex
    subject_match = re.search(r"subject.*?(1\d{7})", msg, re.IGNORECASE)
    admission_match = re.search(r"admission.*?(5\d{7})", msg, re.IGNORECASE)

    if subject_match and admission_match:
        subject_id = int(subject_match.group(1))
        admission_id = int(admission_match.group(1))
    else:
        return Response("‚ùå Please provide a valid subject ID and admission ID.", mimetype="text/html")
    # Load vital data
    vital_data_path = "stroke_agent/stroke_data/vitals_data.csv"
    vital_data = pd.read_csv(vital_data_path)

    # Find patient row
    patient_row = vital_data[(vital_data['subject_id'] == subject_id) & 
                             (vital_data['admission_id'] == admission_id)]

    if patient_row.empty:
        return Response("‚ùå Patient not found in vitals_data.csv.", mimetype="text/html")

    # Extract index and ECG data slice
    patient_index = patient_row.index[0]
    start_idx = patient_row['start'].values[0]
    length = patient_row['length'].values[0]

    ecg_data_path = "stroke_agent/stroke_data/ecg_data.npy"
    ecg_data = np.load(ecg_data_path).reshape((100000, 12))
    patient_data = ecg_data[start_idx:start_idx + length, :]

    # ECG leads
    lead_names = ['I', 'II', 'III', 'aVR', 'aVL', 'aVF', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6']

    # Create 3x4 plot
    fig, axes = plt.subplots(3, 4, figsize=(15, 10))
    axes = axes.flatten()

    for i, ax in enumerate(axes):
        if i < 12:
            ax.plot(patient_data[:, i])
            ax.set_title(f'Lead {lead_names[i]}')
            ax.grid(True, alpha=0.3)

            y_range = np.max(patient_data[:, i]) - np.min(patient_data[:, i])
            scale_bar = y_range * 0.2
            ax.plot([10, 10], [np.min(patient_data[:, i]), np.min(patient_data[:, i]) + scale_bar], 'k-', linewidth=2)

            ax.set_xticks([])
            ax.set_yticks([])
        else:
            ax.axis('off')

    plt.suptitle(f'12-Lead ECG - Subject {subject_id}, Admission {admission_id}', fontsize=16)
    plt.tight_layout()
    plt.subplots_adjust(top=0.92)

    # Convert plot to base64 image
    img = io.BytesIO()
    plt.savefig(img, format='png', dpi=300, bbox_inches='tight')
    img.seek(0)
    plt.close()
    # Encode image to base64
    img_base64 = base64.b64encode(img.read()).decode('utf-8')

    # Generate HTML with embedded image
    html_content = f"""
    <html>
            <img src="data:image/png;base64,{img_base64}" alt="ECG Plot" style="max-width:100%; height:auto;">
    </html>
    """

    return html_content

from pydantic import BaseModel, Field
from typing import Optional

from pydantic import BaseModel, Field
from langchain.tools import tool

class RiskExplanationSchema(BaseModel):
    question: str

@tool(args_schema=RiskExplanationSchema)
def explain_risk_tools() -> str:
    """
    Explains the ASCVD Risk Estimator and ABCD¬≤ Score for stroke prevention planning.
    Triggered after the user agrees to know how they can monitor their health to assess their risk of stroke.
    """

    print("INSIDE RISK CALCULATORS EXPLAINATION NODE")

    return """
‚úÖ Based on your condition, here‚Äôs how we‚Äôll assess your stroke and cardiovascular risk:

üìä **ASCVD Risk Estimator (Atherosclerotic Cardiovascular Disease)**:
Estimates your 10-year and 30-year risk of heart attack or stroke based on:
- Age, sex, race
- Blood pressure
- Cholesterol levels
- Diabetes, smoking, medications

The output guides how aggressively we should manage your lifestyle and medical therapy.

üß† **ABCD¬≤ Score for TIA**:
Predicts short-term stroke risk after a transient ischemic attack (TIA), using:
- Age ‚â•60 (1 point)
- BP ‚â•140/90 mmHg (1 point)
- Clinical symptoms: weakness (2), speech disturbance (1)
- Duration ‚â•60 min (2), 10‚Äì59 min (1)
- Diabetes (1 point)

A high ABCD¬≤ score = higher short-term stroke risk. Let‚Äôs now interpret your actual scores.
"""

class RiskInterpretationSchema(BaseModel):
    ten_year_total_cvd: float
    ten_year_ascvd: float
    ten_year_heart_failure: float
    ten_year_chd: float
    ten_year_stroke: float
    thirty_year_total_cvd: float
    thirty_year_ascvd: float
    thirty_year_heart_failure: float
    thirty_year_chd: float
    thirty_year_stroke: float
    abcd2_score: int

import re
from pydantic import BaseModel
from typing import Annotated
from langchain.tools import tool

class RiskInterpretationSchema(BaseModel):
    input_string: str
    abcd2_score: int

    model_config = {
        "json_schema_extra": {
            "example": {
                "input_string": "...",
                "abcd2_score": 3
            }
        }
    }

@tool(args_schema=RiskInterpretationSchema)
def interpret_risk_scores(data: RiskInterpretationSchema) -> str:
    """
    Interprets cardiovascular and stroke risk results from a formatted input string and ABCD¬≤ score.
    """
    # Extract all percentage values
    percentages = re.findall(r"(\d+\.\d+)%", data.input_string)
    
    if len(percentages) != 10:
        return "‚ùå Error: Could not extract exactly 10 percentage values from input string."

    # Convert to float
    values = [float(p) for p in percentages]

    # Map them to their respective risk categories
    risk_data = {
        "ten_year_total_cvd": values[0],
        "ten_year_ascvd": values[1],
        "ten_year_heart_failure": values[2],
        "ten_year_chd": values[3],
        "ten_year_stroke": values[4],
        "thirty_year_total_cvd": values[5],
        "thirty_year_ascvd": values[6],
        "thirty_year_heart_failure": values[7],
        "thirty_year_chd": values[8],
        "thirty_year_stroke": values[9],
    }

    abcd2 = data.abcd2_score
    abcd2_risk = "Low" if abcd2 <= 3 else "Moderate" if abcd2 <= 5 else "High"

    return f"""
ü©∫ **10-Year Risk:**
- Total CVD: {risk_data['ten_year_total_cvd']}%
- ASCVD: {risk_data['ten_year_ascvd']}%
- Heart Failure: {risk_data['ten_year_heart_failure']}%
- CHD: {risk_data['ten_year_chd']}%
- Stroke: {risk_data['ten_year_stroke']}%

üïí **30-Year Risk:**
- Total CVD: {risk_data['thirty_year_total_cvd']}%
- ASCVD: {risk_data['thirty_year_ascvd']}%
- Heart Failure: {risk_data['thirty_year_heart_failure']}%
- CHD: {risk_data['thirty_year_chd']}%
- Stroke: {risk_data['thirty_year_stroke']}%

üß† **ABCD¬≤ Score: {abcd2}** ‚Üí {abcd2_risk} Risk
- 2-Day: {'1.0%' if abcd2 <= 3 else '4.1%' if abcd2 <= 5 else '8.1%'}
- 7-Day: {'1.2%' if abcd2 <= 3 else '5.9%' if abcd2 <= 5 else '11.7%'}
- 90-Day: {'3.1%' if abcd2 <= 3 else '9.8%' if abcd2 <= 5 else '17.8%'}

‚úî Let's now recommend preventive actions tailored to your profile.
"""
